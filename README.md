# Project: Nexus Search

**A headless, multi-tenant search API to supercharge your product catalog.**

![build](https://img.shields.io/badge/build-passing-brightgreen) ![docs](https://img.shields.io/badge/docs-complete-blue) ![license](https://img.shields.io/badge/license-MIT-lightgrey)

## What is Nexus Search?

Nexus Search is a multi-tenant, search-as-a-service platform designed for developers and product teams. It provides the backend infrastructure to let your clients (tenants) define their own product schemas, import data, and get a blazing-fast, secure search API endpoint to embed anywhere.

Think of it as your own private, customizable Algolia or Elasticsearch instance for each of your customers, but without the DevOps headache.

### Core Features

- ✅ **Dynamic, Per-Tenant Schemas:** Let your users define their own data structures with custom tags, types, and search rules.
- ✅ **Powerful Full-Text Search:** Backed by Elasticsearch, with language analysis, per-tenant synonyms, and relevance tuning.
- ✅ **Effortless Data Ingestion:** Bulk import via CSV through an asynchronous pipeline or manage products with a simple CRUD API.
- ✅ **Headless & Secure API:** Each tenant gets a unique, rate-limited API key and a dedicated endpoint for their search.
- ✅ **Built to Scale:** Asynchronous job processing using a modern, cloud-native architecture.

## How It Works: The Architecture

The system is designed as a modern, cloud-native application with a clear separation of concerns:

- **Frontend:** A React/Vue/Svelte Single-Page Application (SPA) serving as the tenant-facing **Admin Panel**.
- **Backend API:** A Node.js (Express/NestJS) application acting as the central controller.
- **Metadata Store:** **MongoDB** serves as the primary database for all tenant information, product schema definitions, and synonym lists.
- **Data Ingestion Pipeline:**
  - **Amazon S3:** For staging large CSV product imports.
  - **Amazon SQS:** To queue import jobs for reliable, asynchronous processing.
  - **Processor Service:** A serverless function (e.g., AWS Lambda) that consumes from SQS, validates data, and indexes it.
- **Search Engine:** **Elasticsearch**, using a dedicated **index-per-tenant** strategy for strong data isolation and custom schema/synonym support.
- **Caching Layer:** **Redis** for caching frequently accessed metadata and popular search queries to improve performance and reduce database load.

---

## Development Roadmap & Tasks

This roadmap is broken down into milestones, starting with the core MVP and building out features progressively.

### Milestone 1: Core MVP - The Foundation

_(Goal: A single tenant can define a schema, import data, and get a searchable endpoint. All core infrastructure is in place.)_

| Backend Tasks                                                                                                                                                                                                                                                                                                                                                                  | Frontend Tasks                                                                                                                                                                                                                                                                                                                                                                                 |
| :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1. Setup & API Foundation:**<br> - Initialize Node.js project (Express/NestJS).<br> - Setup Docker for local development environment (Node, Mongo, Elastic, Redis).<br> - Implement initial server setup and configuration management (`dotenv`).                                                                                                                            | **1. Project Setup:**<br> - Initialize React/Vue project with Vite.<br> - Setup routing, basic layout, and a component library (e.g., Material-UI, Shadcn/ui).<br> - Configure ESLint, Prettier for code quality.                                                                                                                                                                              |
| **2. Tenant Authentication & Metadata:**<br> - Implement JWT-based authentication for tenant admins (login, logout, registration).<br> - Create Mongoose models and API endpoints for `Tenant` and `User`.<br> - **Best Practice:** Hash passwords (`bcrypt`). Ensure all API routes are protected.                                                                            | **2. Authentication Flow:**<br> - Create Login, Registration, and protected route components.<br> - Implement token storage (secure `httpOnly` cookies) and an API client (e.g., Axios) with interceptors to handle auth headers and token refresh.<br> **Best Practice:** Use a state management library (e.g., Zustand, Redux Toolkit) for user state.                                       |
| **3. Schema Definition Core:**<br> - Design Mongoose model for `ProductSchema` (linked to `tenantId`).<br> - Create CRUD API endpoints for managing schema tags (`/api/v1/schemas`).<br> - **Best Practice:** Use a validation library like `zod` or `class-validator` for all incoming API requests.                                                                          | **3. Schema Builder UI:**<br> - Build an intuitive UI for a tenant to define their product schema.<br> - Allow adding/removing tags, and defining properties for each tag (name, type, required).<br> **Best Practice:** Use a data-fetching library like **TanStack Query** (React Query) to handle API state, which provides caching, de-duplication, and optimistic updates out-of-the-box. |
| **4. Elasticsearch Provisioning:**<br> - Write a service that, upon schema creation/update, programmatically creates an Elasticsearch index for the tenant (e.g., `products_{tenantId}`).<br> - Implement the logic to translate the `ProductSchema` from Mongo into an Elasticsearch mapping (handling `text`, `keyword`, and `number` types).                                | **4. Basic Dashboard:**<br> - Create a main dashboard page where the Schema Builder will live.                                                                                                                                                                                                                                                                                                 |
| **5. Search API (v1):**<br> - Create a secure, tenant-facing search endpoint (`/api/v1/search`).<br> - Implement API Key generation and authentication for this endpoint.<br> - The endpoint should accept a query and forward it to the correct tenant's Elasticsearch index.<br> - **Best Practice:** Implement basic rate limiting (`express-rate-limit`) to prevent abuse. |                                                                                                                                                                                                                                                                                                                                                                                                |

---

### Milestone 2: Data Management & Feature Expansion

_(Goal: Enable tenants to easily get data into the system and leverage more powerful search features.)_

| Backend Tasks                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Frontend Tasks                                                                                                                                                                                                                                                                                                                  |
| :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **1. Manual Product Management:**<br> - Create Mongoose models for Products (or decide to only store in ES).<br> - Create API endpoints for manual `CRUD` on individual products.<br> - On create/update/delete, immediately push the change to that tenant's Elasticsearch index.                                                                                                                                                                                                                                                                                                       | **1. Product Management UI:**<br> - Create a table/list view to display imported products.<br> - Build forms for manually adding/editing a single product, dynamically generated from the tenant's schema.<br> **Best Practice:** Implement client-side validation for instant user feedback.                                   |
| **2. CSV Import Pipeline:**<br> - Create an API endpoint to get a secure, pre-signed URL for uploading a CSV to S3.<br> - Set up S3 bucket to trigger an event on object creation, pushing a message to an SQS queue. The message must contain the `s3_key` and `tenant_id`.<br> - Create the Processor (AWS Lambda) to consume from SQS.<br> - **Best Practice:** Processor logic must be robust: fetch schema from Mongo, validate CSV headers against schema, parse rows, batch-insert into Elasticsearch, and handle errors gracefully (e.g., send bad rows to a Dead Letter Queue). | **2. CSV Import Page:**<br> - Build the UI for file upload (drag-and-drop area).<br> - Show upload progress and provide clear feedback (queued, processing, completed, failed).<br> **Best Practice:** Use TanStack Query to poll a status endpoint to give the user live updates on the import process without a page refresh. |
| **3. Advanced Schema & Search:**<br> - Enhance the `ProductSchema` model to support `searchability` (`both`, `keyword`, `fulltext`) and `language`.<br> - Update the Elasticsearch provisioning service to create multi-fields (`.keyword`) and apply language analyzers based on the schema.<br> - Update the Search API to intelligently use the `text` field for `match` queries and the `.keyword` field for `term` filters.                                                                                                                                                         | **3. Enhance Schema Builder UI:**<br> - Add UI controls (dropdowns, toggles) for `searchability` and `language` to the schema builder.                                                                                                                                                                                          |
| **4. Metadata Caching:**<br> - Implement a **Redis** caching layer for `ProductSchema` documents.<br> - When a request comes to the search or import API, first check Redis for the schema before hitting MongoDB.<br> - **Best Practice:** Use a clear cache invalidation strategy (e.g., invalidate the cache whenever a tenant updates their schema).                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                 |

---

### Milestone 3: Advanced Features & Optimization

_(Goal: Differentiate the product with professional-grade features and ensure performance at scale.)_

| Backend Tasks                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Frontend Tasks                                                                                                                                                                                                                                                                                      |
| :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1. Synonym Management:**<br> - Add a `synonyms` array to the `ProductSchema` model in MongoDB.<br> - Create API endpoints for CRUD operations on the tenant's synonym list.<br> - Update the Elasticsearch provisioning service: when an index is created, it must fetch the synonyms and build a custom analyzer for that specific tenant's index.<br> - **Best Practice:** Because this requires re-indexing, manage it carefully. Create a new index (`_v2`), re-index data in the background, and then atomically switch an alias to point to the new index to ensure zero downtime. | **1. Synonym Management UI:**<br> - Create a new page in the Admin Panel for synonym management.<br> - Provide a simple UI (e.g., a tag-input field) for tenants to add/remove synonym groups.<br> - Implement a CSV upload feature for bulk synonym import, with clear instructions on the format. |
| **2. Relevance Tuning & Weights:**<br> - Enhance the `ProductSchema` to include `relevance_weight` on tags.<br> - Update the Search API to use these weights to construct boosted queries in Elasticsearch, giving more importance to matches in fields like `product_name` over `description`.                                                                                                                                                                                                                                                                                            | **2. Add Weights to Schema UI:**<br> - Add a number input for `relevance_weight` in the schema builder UI.                                                                                                                                                                                          |
| **3. Search Query Caching:**<br> - On the public-facing Search API, implement Redis caching for common search queries.<br> - **Best Practice:** Generate a cache key from the `tenantId` + `query_string`. Store the JSON result from Elasticsearch. Set a short TTL (e.g., 5-10 minutes) to keep results fresh.                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                     |
| **4. Logging and Monitoring:**<br> - Integrate a structured logging library (e.g., Pino, Winston).<br> - Set up monitoring and alerts (e.g., using AWS CloudWatch or a service like Datadog) for API error rates, Lambda function health, and SQS queue depth.                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                     |
| **5. Infrastructure as Code (IaC):**<br> - Write scripts to define and deploy all your AWS infrastructure (S3, SQS, Lambda, IAM roles) using a tool like **Terraform** or **AWS CDK**.<br> - **Best Practice:** This makes your setup repeatable, version-controlled, and professional.                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                     |
